---
title: Scala的val与var
date: 2017/03/08
tags:
 - scala
categories:
 - 学习

---
### Scala编程Martin Odersky, Lex Spoon, Bill Venners
最近学习Scala 感觉蛮高大上的，记记笔记

总论 ： Scala有两种变量：var和val。val类似与Java种的final变量，一旦初始化了，就不能再被赋值。相反，var可以在生命周期内被多次赋值!

如定义：
```java
val msg = "Hello, world!"
```

演示了类型推断： type inference，这种 Scala能自动理解你省略的类型的能力。

在这个例子里，因为你用一个字串文本初始化了 msg，Scala 推断 msg 的类型是 String。
如果 Scala 解释器（或编译器）可以推断类型，那么让它这么做而不是写一些没必要的显式类型标注常常是最好的选择。
不过，如果你愿意，也可以显式地定义类型，也许有些时候你也应该这么做。
显式的类型标注不但可以确保 Scala编译器推断你倾向的类型， 还可以作为将来代码读者有用的文档。 

Java 中变量的类型指定在其名称之前，与之不同的是， Scala 里变量的类型在其名称之后，用冒号分隔。

如：
```java
val msg2: java.lang.String = "Hello again, world!"
```
再有：
```java
 val greetStrings = new Array[String](3)
    greetStrings(0) = "Hello"
    greetStrings(1) = ", "
    greetStrings(2) = "world!\n"
    for (i <- 0 to 2)
    print(greetStrings(i))
```
如果想用一种更显式的方式，你可以显式定义 greetStrings 的类型：

```java 
val greetStrings: Array[String] = new Array[String](3)
```

由于 Scala 有类型推断，这行代码与代码 3.1 里的第一行代码语义一致。不过这种形式说明了类型参数化部分（方括号里的类型名）形成了实例类型的部分，而值参数化部分（圆括号里的值） 不是。 greetStrings 的类型是 Array[String]， 不是 Array[String](3)。

三行代码初始化了 greetStrings 数组的每个元素：

```java
greetStrings(0) = "Hello"
    greetStrings(1) = ", "
    greetStrings(2) = "world!\n"
```

正如前面提到的， Scala 里的数组是通过把索引放在圆括号里面访问的，而不是像 Java 那样放在方括号里。

所以数组的第零个元素是 greetStrings(0)，不是 greetStrings[0]。

这三行代码演示了搞明白 Scala 如何看待 val 的意义的重要概念。

当你用 val 定义一个变量，那么这个变量就不能重新赋值，但它指向的对象却仍可以暗自改变。
所以在本例中，你不能把 greetStrings 重新赋值成不同的数组； 
greetStrings 将永远指向那个它被初始化时候指向的同一个 Array[String]实例。但是你能一遍遍修改那个 Array[String]的元 素，因此数组本身是可变的。
